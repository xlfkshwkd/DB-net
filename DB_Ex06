SELECT * FROM EMP;

SELECT * FROM DEPT;

SELECT * FROM SALGRADE;

CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
--복사

SELECT * FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO,DNAME,LOC) VALUES(1,'DATEBASE','INCHEON');

INSERT INTO DEPT_TEMP VALUES(2,'DATABASE2','GAWONDO');

INSERT INTO DEPT_TEMP VALUES(2,'DATABASE2',NULL);

INSERT INTO DEPT_TEMP VALUES(80,'MOBLE',''); 
--비어있는값을 넣으면 자동으로 널값을 넣어준다 

INSERT INTO DEPT_TEMP(DNAME,DEPTNO,LOC) VALUES(80,'DSD',4564);
--순서 이상하게 넣으면 들어가지 않는다. 
-------------------------------------------------------------------------------
CREATE TABLE EMP_TEMP  AS SELECT * FROM EMP WHERE 1<>1;
--복사를하는대 형식만 복사하고 값을 복사안함 
--	<> , != ,^= 

INSERT INTO EMP_TEMP (EMPNO,ENAME,JOB,HIREDATE) VALUES (9999,'SIM','CLECK','2023-09-12');

INSERT INTO EMP_TEMP (EMPNO,ENAME,JOB,HIREDATE) VALUES (9999,'SIM','CLECK','08-29-2023');
--형식 박살나서 몰라유 

INSERT INTO EMP_TEMP (EMPNO,ENAME,JOB,HIREDATE) VALUES (9999,'SIM','CLECK',TO_DATE('08-29-2023','MM-DD-YYYY'));
-- TO-DATE 함수 써서 형식을 이해 하게됨 

--INSERT INTO EMP_SALGRADE SELECT..

CREATE TABLE DEPT_TEMP2 AS SELECT *FROM DEPT;

SELECT *FROM DEPT_TEMP2;

UPDATE DEPT_TEMP2 SET LOC ='SEOUL';
-- 조건없으면 모든레코드가 영향을 미침 

--트랜잭션 COMMIT 하기전까지가 하나의 실행 단위;
--:COMMIT;:DB에 영구 반영 
ROLLBACK;
--다음 시험 문제 
--DDL 이거는 안됌 그냥 만들어지자마자 커밋이되어버림

UPDATE DEPT_TEMP2 SET LOC ='SEOUL' WHERE LOC='NEW YORK';

UPDATE DEPT_TEMP2 SET DNAME='DATABASE' ,LOC='SEUOL' WHERE DEPTNO =40;

DELETE FROM DEPT_TEMP2 WHERE DEPTNO =40;
CREATE TABLE EMP_TEMP2 AS SELECT *FROM EMP;

SELECT *FROM EMP_TEMP2 ;

DELETE FROM EMP_TEMP2 WHERE JOB ='MANAGER';
ROLLBACK;

SELECT *FROM EMP_TEMP2 ;

DELETE FROM EMP_TEMP2; 
--DML 커밋하기전이면롤백이 가능하다 

TRUNCATE TABLE EMP_TEMP2  ;
--DDL :테이블 비우기 복구 불가능 


--트랜잭션 제어와 섹션 커밋하기 전까지 하나의 트랜잭션 --TCL 커밋과 롤백 두가지의 미 
--하나의 트랜잭션 단위에서 하나라도 에러가 발생하면 전체 쿼리 취소 

--commit BD 영구 반영 

DROP TABLE DEPT_TEMP ;
DROP TABLE DEPT_TEMP2 ;

DROP TABLE EMP_TEMP;
DROP TABLE EMP_TEMP2;

CREATE TABLE DEPT_TCL AS SELECT *FROM DEPT;

SELECT * FROM DEPT_TCL ;

INSERT INTO DEPT_TCL VALUES(50,'DATABASE','INCHEON');

--아직 메모리상에만 저장 
DELETE FROM DEPT_TCL WHERE DNAME='RESEARCH';



UPDATE DEPT_TCL SET LOC='BUSAN' WHERE DEPTNO =40;

ROLLBACK;
COMMIT;

------------------------------------------------------------

DROP TABLE DEPT_TCL ;

CREATE TABLE DEPT_TCL AS SELECT *FROM DEPT;

SELECT *FROM DEPT_TCL  ;

UPDATE DEPT_TCL  SET LOC ='SEOUL'WHERE DEPTNO =40;
ROLLBACK;
INSERT INTO DEPT_TCL VALUES(50,'DATEABASE','INCHEON');
INSERT INTO DEPT_TCL VALUES(60,'DATEABASE2','INCHEON2');
COMMIT;

UPDATE DEPT_TCL  SET LOC='SEOUL' WHERE DNAME ='WEB';

--숫자 문자 
--오라클 자료형은 간단함 
--NUMBER(전채 자리수 ,소수점 자리수 )
--	정수일때는 소수점 자리수가 0이거나 입력 x
--	실수 : 소수점 자리수를 설정 

--문자 CHAR(길이) 고정사이즈 문자열을 입력할때 
-- CHAR(5) 5자리 
-- KR :실데이터는 2개 하지만 메모리에서는 5자리를 차지한다 ! 
--VARCHAR2(20) 가변길이 최대길이 
--	 VARCHAR() 가변사이즈 문자열 
-- 최대 100자 /4000자(바이트까지가능 )  한글한자는 3BYTE 임 
-- KR ->2자
--COLB
--CHARACTER  LAGEOBJECT 최대 4 GB까지 가능 
--BLOB
-- 파일데이터도 저장이 가능 

--날짜 DATE  --데이터의 일관성을 위해서 정해주는것  

--CREATE 생성 ALTER 수정 DROP 삭제 

--컬럼명 오라클은 전부 대문자 .단어와 단어사이의 _관








--한쪽에서 새션을 작업하면 다른한쪽은 잠긴다. 늦은놈은 얄짤없다 .읽기의 일관성 
--세션간의 데이터 공유는 COMMIT 이후에 가능함 


--------------------------------------------
CREATE TABLE EMP_DDL (
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGB NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2)

);

CREATE TABLE DEPT_DDL (
	DEPTNO NUMBER(2),
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)

);

CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;

SELECT *FROM  EMP_ALTER;

ALTER TABLE EMP_ALTER ADD P_N VARCHAR2(20);

ALTER TABLE EMP_ALTER RENAME COLUMN P_N TO CELLPHONE;
--이름변경 

ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
--제약조건 변경 
--컬럼명 제약조건
--컬럼명 자료형 제약 조건 
ALTER TABLE EMP_ALTER DROP COLUMN CELLPHONE;


--삭제 
--RENAME 기존 테이블 명
--RENAME 기존 태이블명 TO 바꾼테이블명 

RENAME EMP_ALTER TO EMP_RENAMEL;

DROP TABLE DEPT_DDL ;
DROP TABLE DEPT_TCL  ;
DROP TABLE EMP_RENAMEL  ;

COMMIT;

SELECT *FROM DICT;

SELECT * FROM USER_TABLES;
--인덱스 조회는 빠르지만 데이터의 양이 많아 질수록 추가변경 삭제시 느려지는 문제 

SELECT MAX(SAL) ,MIN(SAL) FROM EMP;

--SELECT SAL FROM EMP ASC;

--CREATE INDEX 인덱스 이름 
--  ON 테이블 이름(열 이름1 ASC or DESC, 
--                열 이름2 ASC or DESC,
--	 ...                  );

CREATE TABLE EMP_INDEX AS SELECT *FROM EMP;

CREATE INDEX IDX_EMPIN_SAL ON EMP_INDEX(SAL DESC);

-- USER_IND_COLUNNS : 부여된 인덱스 정보 .제약 조건에 해당하는 컬럼 명도 확인 가능 

SELECT *FROM USER_INDEXES;

SELECT * FROM USER_IND_COLUMNS;

DROP INDEX IDX_EMPIN_SAL;

SELECT * FROM emp,dept WHERE DEPT.DEPTNO =EMP.DEPTNO  ;

SELECT EMP.EMPNO, EMP.ENAME ,EMP.JOB ,EMP.DEPTNO,DEPT.DNAME  
FROM EMP,DEPT WHERE DEPT.DEPTNO =EMP.DEPTNO  ;

--등가 조인 /내부조인 /단순조인 

-- 비등가 조인 
EMP,SALGR

SELECT *FROM EMP;

SELECT *FROM SALGRADE;

SELECT E.*,S.GRADE  FROM EMP E,SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL ;



SELECT E.*,S.GRADE  FROM EMP E,SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL ;

--자체 조인 EMP.MGR : 관리자 번호 -직원번호 (EMP.EMPNO)

SELECT E1.*,E2.ENAME MGRNAME FROM EMP E1,EMP E2
WHERE E1.MGR=E2.EMPNO ;
--동일 테이블 조인 셀프 조인 
SELECT * FROM EMP;


--외부조인 

--SELECT * FROM DEPT;

CREATE TABLE DEPT_SUB (
	SUBNO NUMBER(2) CONSTRAINTS PK_SUBNO PRIMARY KEY,
	SNAME VARCHAR2(20),
	DEPTNO NUMBER(2)

);

ALTER TABLE DEPT_SUB MODIFY SNAME VARCHAR2(22);

INSERT INTO DEPT_SUB VALUES(10,'추가정보',10);

INSERT INTO DEPT_SUB VALUES(20,'추가정보2',10);
INSERT INTO DEPT_SUB VALUES(30,'추가정보3',20);
INSERT INTO DEPT_SUB VALUES(40,'추가정보4',20);

INSERT INTO DEPT_SUB VALUES(50,'추가정보5',30);
INSERT INTO DEPT_SUB VALUES(60,'추가정보6',30);

SELECT *FROM DEPT_SUB;

SELECT *FROM DEPT D,DEPT_SUB S WHERE D.DEPTNO =S.DEPTNO(+);

SELECT *FROM DEPT D,DEPT_SUB S WHERE D.DEPTNO(+) =S.DEPTNO;

SELECT *FROM DEPT D,DEPT_SUB S WHERE D.DEPTNO =S.DEPTNO;


--왼쪽 외부 조인 

--MATUAL JOIN
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D 
ORDER BY DEPTNO, E.EMPNO;



SELECT *
FROM EMP E INNER JOIN DEPT D USING(DEPTNO);
-- 기본적인 컬럼명과 번호가 같아야함 

SELECT * FROM EMP E JOIN DEPT D ON E.DEPTNO =D.DEPTNO ;

SELECT E.EMPNO,E.ENAME,E.JOB, E.DEPTNO, D.DNAME,S.SNAME 
FROM EMP E JOIN DEPT D ON E.DEPTNO =D.DEPTNO JOIN DEPT_SUB S ON
D.DEPTNO =S.DEPTNO ;


SELECT * FROM EMP E 
LEFT OUTER JOIN DEPT D ON E.DEPTNO =D.DEPTNO ;

SELECT * FROM DEPT E 
LEFT OUTER JOIN DEPT_SUB D ON E.DEPTNO =D.DEPTNO ;


SELECT * FROM DEPT D 
RIGHT OUTER JOIN DEPT_SUB S ON D.DEPTNO =S.DEPTNO ;


SELECT * FROM DEPT D FULL OUTER JOIN
DEPT_SUB S ON D.DEPTNO =S.DEPTNO ;

--서브 쿼리 : SELECT 문안에 SELECT 문 
--스칼라 부속 질의 단일값 

--SELECT (SELECT ...)-> 단일 값 FROM 

--2) 인라인 뷰  SELECT FROM ..... 
SELECT E.*,
(SELECT D.DNAME FROM DEPT D WHERE D.DEPTNO =E.DEPTNO) DNAME 
FROM EMP E;
--단일 스칼라 부속  

--3) 상관 부속 질의 
--단일행 서브 쿼리 
-- -조건식 (=,<,>.<>)
--다중행 서브 쿼리 

SELECT * FROM EMP E
WHERE E.HIREDATE >(SELECT MAX(HIREDATE) 
FROM EMP WHERE DEPTNO=30);

SELECT * FROM EMP;

SELECT * FROM EMP WHERE SAL<(SELECT MIN(SAL) 
FROM EMP WHERE DEPTNO=30)

--ALL 모든 레코드가 조건에 참 .ANY(SOME) -어떤레코드 


SELECT *FROM EMP WHERE SAL<ALL 
(SELECT SAL FROM EMP WHERE DEPTNO=30) ;

SELECT *FROM EMP 
WHERE SAL <(SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30 );

SELECT * FROM EMP 
WHERE SAL<ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);

 
SELECT * FROM EMP WHERE DEPTNO =30 ORDER BY SAL DESC

-- ALL 모든 조건이 참 ,
SELECT * FROM EMP WHERE SAL < ALL(SELECT SAL FROM WHERE DEPTNO=30)

SELECT SAL FROM EMP WHERE DEPTNO =30 ORDER BY SAL;












































































